\ProvidesPackage{mttex}

%%% -------------------------- Packages -------------------------------

\RequirePackage{mathpartir}
% Local packages

% CTAN packages
\RequirePackage{pgffor}
\RequirePackage{xcolor}
\RequirePackage{letltxmacro}

\RequirePackage{ifthen}

\RequirePackage{amsbsy}
\RequirePackage[only,llbracket,rrbracket]{stmaryrd}

\RequirePackage{url}

\RequirePackage{hyperref}

% ACM recommended packages
\RequirePackage{microtype}
\RequirePackage[utf8]{inputenc}
\RequirePackage[T1]{fontenc}

%%% -------------------------- Options -------------------------------

%% omitthis
\newcommand{\omitthis}[1]{#1}

\newif\ifsecc@omit
\secc@omitfalse
\DeclareOption{omit}{
  \renewcommand{\omitthis}[1]{}
  \secc@omittrue
}

\makeatletter
% todo
\newif\ifsecc@todo
\secc@todofalse
\DeclareOption{todo}{\secc@todotrue}

%% ACM/SIGPLAN format
\newif\ifsecc@sigplan
\secc@sigplanfalse

\DeclareOption{sigplan}{\secc@sigplantrue}
\DeclareOption{nosigplan}{\secc@sigplanfalse}

%% balance the last page?
\newif\ifsecc@balance
\secc@balancefalse

\DeclareOption{balance}{\secc@balancetrue}

%% techrpt or paper?
\newif\ifsecc@techrpt
\secc@techrptfalse

\DeclareOption{techrpt}{\secc@techrpttrue}
\DeclareOption{paper}{\secc@techrptfalse}

%clever references stuff?
\newif\ifsecc@refstuff
\secc@refstufffalse

% for backwards compatibility
\DeclareOption{refstuff}{\secc@refstufftrue}
\DeclareOption{magicref}{\secc@refstufftrue}

%titlecaps usage?
\newif\ifsecc@titlecaps
\secc@titlecapstrue

\DeclareOption{notitlecaps}{\secc@titlecapsfalse}

%nocompress ?
\newif\ifsecc@compress
\secc@compresstrue

\DeclareOption{nocompress}{\secc@compressfalse}

\ProcessOptions\relax

\ifsecc@todo
\else
  \ifsecc@omit
    \PassOptionsToPackage{hide}{todo}
  \fi
\fi
\RequirePackage[marginpar]{todo}

\ifsecc@balance
  \RequirePackage{flushend}
\fi

\ifsecc@techrpt
  \RequirePackage{fullpage}
  \renewcommand{\baselinestretch}{1.0}
\fi

\ifsecc@compress
  \pdfminorversion=5
  \pdfcompresslevel=9
  \pdfobjcompresslevel=2
\else
  \relax
\fi
\makeatother

%%% ----------------------- Definitions -----------------------------

\makeatletter
\ifsecc@titlecaps
\RequirePackage{titlecaps}
%% Automaigc titlecase
\Addlcwords{for via a is but and with of in as the etc on to if}

% TODO I'd rather like to hide these internal things, but I guess I'll
% settle for making them @ protected
\LetLtxMacro{\@title}{\title}
\LetLtxMacro{\@section}{\section}
\LetLtxMacro{\@subsection}{\subsection}
\LetLtxMacro{\@subsubsection}{\subsubsection}

\newcommand{\@titlecrafterStar}[2]{
  #1*{\titlecap{#2}}
}

\newcommand{\@titlecrafterNoStar}[3]{
  \ifthenelse{\equal{#2}{}}
  {#1[#3]{\titlecap{#3}}}
  {#1[#2]{\titlecap{#3}}}
}

\newcommand{\@titleStar}[1]{
  {\@title*{\titlecap{#1}}}
}

\newcommand{\@titleNoStar}[1]{
  {\@title{\titlecap{#1}}}
}

\renewcommand{\title}{ \@ifstar \@titleStar \@titleNoStar }

\newcommand{\@sectionStar}{
  \@titlecrafterStar{\@section}
}

\newcommand{\@sectionNoStar}[2][]{
  \@titlecrafterNoStar{\@section}{#1}{#2}
}

\renewcommand{\section}{
  \@ifstar \@sectionStar \@sectionNoStar
}

\newcommand{\@subsectionStar}{
  \@titlecrafterStar{\@subsection}
}

\newcommand{\@subsectionNoStar}[2][]{
  \@titlecrafterNoStar{\@subsection}{#1}{#2}
}

\renewcommand{\subsection}{
  \@ifstar \@subsectionStar \@subsectionNoStar
}

\newcommand{\@subsubsectionStar}{
  \@titlecrafterStar{\@subsubsection}
}

\newcommand{\@subsubsectionNoStar}[2][]{
  \@titlecrafterNoStar{\@subsubsection}{#1}{#2}
}

\renewcommand{\subsubsection}{
  \@ifstar \@subsubsectionStar \@subsubsectionNoStar
}
\fi
\makeatother

%% Misc commands <<<
%% More automatic "reference stuff"

\makeatletter
\ifsecc@refstuff

  \usepackage{nameref}
  \usepackage{cleveref}
  % http://tex.stackexchange.com/questions/121865/nameref-how-to-display-section-name-and-its-number
  % , modified to use \Cref instead of \autoref
%  \LetLtxMacro{\oldnameref}{\nameref}
%  \renewcommand{\nameref}[1]{\hyperref[{#1}]{\oldnameref*{#1}}}
  \newcommand{\magicstring}{@}
  \newcommand*{\@fullref}[3]{%
\def \@meow{\ifthenelse{\equal{#1}{\magicstring}}{\nameref*{#3}}{#1}}%
\sbox0{\@meow}%
\hyperref[{#3}]{#2%
\ifdim\wd0=0pt%
\else%
~(\@meow)%
\fi}%
\def\@meow{\undefined}%
}

  \newcommand{\@fullrefNoStar}[2][\magicstring]{\@fullref{#1}{\Cref*{#2}}{#2}}
  \newcommand{\@fullrefStar}[3][\magicstring]{\@fullref{#1}{#2\ref*{#3}}{#3}}
  \newcommand{\fullref}{\@ifstar\@fullrefStar\@fullrefNoStar}
  % here for backwards compatibility
  \newcommand{\nameonlyref}{\nameref}
  \newcommand{\fullrefnoname}[1]{\@fullrefNoStar[]{#1}}
  \newcommand{\shortref}[1]{\@fullrefNoStar{#1}}
  \newcommand{\fullrefnamed}{\@fullrefStar}

  \newcommand{\secref}[1]{\!\fullref[]{#1}}
  \newcommand{\figref}[1]{\!\fullref[]{#1}}
  \newcommand{\lemref}[1]{\!\fullref[]{#1}}
  \newcommand{\thmref}[1]{\!\fullref[]{#1}}
  \newcommand{\corref}[1]{\!\fullref[]{#1}}
\else
  \newcommand{\secref}[1]{\S\ref{#1}}
  \newcommand{\figref}[1]{Figure~\ref{#1}}
  \newcommand{\lemref}[1]{Lemma~\ref{#1}}
  \newcommand{\thmref}[1]{Theorem~\ref{#1}}
  \newcommand{\corref}[1]{Corollary~\ref{#1}}
\fi
\makeatother

% TODO: Document
\newcommand{\judgmath}[1]{\(#1\)}
\newcommand{\judgshape}[2][]{\begin{flushleft}\fbox{\judgmath{#2}~#1}\end{flushleft}}
\newcommand{\inlinemath}[1]{\(#1\)}
\newcommand{\im}{\inlinemath}
\newcommand{\nonbreaking}{\mbox}
\newcommand{\rulename}[1]{[{\scshape #1}]}

% Text mode
\newenvironment{nop}{\ifvmode\nointerlineskip\fi}{\ignorespacesafterend}

% Stack formatting
\newenvironment{stackAux}[2]{%
\setlength{\arraycolsep}{0pt}
\begin{array}[#1]{#2}}{
\end{array}\ignorespacesafterend}
\newenvironment{stackCC}{
\begin{stackAux}{c}{c}}{\end{stackAux}\ignorespacesafterend}
\newenvironment{stackCL}{
\begin{stackAux}{c}{l}}{\end{stackAux}\ignorespacesafterend}
\newenvironment{stackTL}{
\begin{stackAux}{t}{l}}{\end{stackAux}\ignorespacesafterend}
\newenvironment{stackTR}{
\begin{stackAux}{t}{r}}{\end{stackAux}\ignorespacesafterend}
\newenvironment{stackBC}{
\begin{stackAux}{b}{c}}{\end{stackAux}\ignorespacesafterend}
\newenvironment{stackBL}{
\begin{stackAux}{b}{l}}{\end{stackAux}\ignorespacesafterend}

\newcommand{\case}[1][]{\item[Case] #1}
\newcommand{\scase}[1][]{\item[Sub-Case] #1}
\newcommand{\sscase}[1][]{\item[Sub-Sub-Case] #1}

%% Meta Language
\newcommand{\metafont}[1]{\mathrm{#1}}
\newcommand{\dom}[1]{\metafont{dom}(#1)}
\newcommand{\cod}[1]{\metafont{cod}(#1)}
\newcommand{\rng}[1]{\metafont{rng}(#1)}
\newcommand{\FV}{\metafont{fv}}
\newcommand{\FTV}{\metafont{ftv}}
\newcommand{\subst}[3]{{#1}[{#2}/{#3}]}
\newcommand{\defeq}{\stackrel{\metafont{def}}{=}}
\newcommand{\finmap}{\stackrel{\metafont{fin}}{\rightarrow}}
\renewcommand{\iff}{\metafont{iff}}
\newcommand{\lsem}{\left\llbracket}
\newcommand{\rsem}{\right\rrbracket}
\newcommand{\sembrace}[1]{\lsem{#1}\rsem}
\newcommand{\powset}[1]{\mathscr{P}(#1)}
\newcommand{\irred}[1]{\metafont{irred}(#1)}
\renewcommand{\max}[2]{\metafont{max}(#1,#2)}
\newcommand{\free}[2]{\metafont{free}(#1,#2)}
\newcommand{\running}[2]{\metafont{running}({#1},{#2})}
\newcommand{\pair}[2]{( #1, #2 )}
\newcommand{\triple}[3]{( #1, #2, #3 )}

\newcommand{\satisfy}{\vDash}

\newcommand{\plus}{+}
\newcommand{\etal}{\textit{et al.}}
\newcommand{\ie}{\emph{i.e.}}
\newcommand{\eg}{\emph{e.g.}}
\newcommand{\etc}{\emph{etc.}}
\newcommand{\bump}{\hspace{3.5pt}}
\newcommand{\fresh}[1]{(\mathit{fresh}\:#1)}
\newcommand{\where}[1]{\mathrm{where}\:#1}

\newcommand{\lang}[1]{\mathrm{\textrm{#1}}}

%% Standard symbols

\newcommand{\emptyenv}{\cdot}
\newcommand{\emptyctx}{[\cdot]}
\newcommand{\hole}{\emptyctx}
\newcommand{\hw}[1]{\lbrack{#1}\rbrack}
\newcommand{\ectx}{E}
\newcommand{\ctx}{C}

\newcommand{\hooklongrightarrow}{\lhook\joinrel\longrightarrow}
\newcommand{\redexstep}{\hookrightarrow}
\newcommand{\redexstepinv}{\hookleftarrow}

\newcommand{\step}{\longmapsto}
\newcommand{\stepin}[1]{\step^{#1}}
\newcommand{\stepstar}{\stepin{*}}

\newcommand{\red}{\Downarrow}
\newcommand{\diverg}[1]{#1 \Uparrow}

\newcommand{\termin}[1]{#1\red}
\newcommand{\terminw}[2]{\termin{#1} #2}

\newcommand{\transarrow}{\leadsto}
\newcommand{\backtransarrow}{\twoheadrightarrow}

\newcommand{\funarrow}{\rightarrow}
\newcommand{\ctxarrow}{\Rightarrow}

% BNF symbols
\newcommand{\bnflabel}[1]{\mbox{\textit{#1}}}
\newcommand{\bnfalt}{\mathrel{\bf \,\mid\,}}
\newcommand{\bnfdef}{\mathrel{\bf ::=}}
\newcommand{\bnfadd}{\mathrel{\bf +::=}}
\newcommand{\bnfsub}{\mathrel{\bf -::=}}

%% Language Formatting combinators

% Copy-pasta: http://tex.stackexchange.com/questions/16189/repeat-command-n-times
\makeatletter
\newcommand{\Repeat}[1]{%
  \expandafter\@Repeat\expandafter{\the\numexpr #1\relax}%
}

\def\@Repeat#1{%
  \ifnum#1>0
    \expandafter\@@Repeat\expandafter{\the\numexpr #1-1\expandafter\relax\expandafter}%
  \else
    \expandafter\@gobble%
  \fi
}
\def\@@Repeat#1#2{%
  \@Repeat{#1}{#2}{#2}%
}

\newcommand{\@super}[3]{
  \ifnum#3=0
  {\sbox0{\ensuremath{#1}}%
    \ifdim\wd0=0pt
    \else%
^{#1}%
    \fi}
  \else
^{\Repeat{#3}{#2}#1}%
  \fi
}

\newcommand{\@sub}[1]{
  \sbox0{\ensuremath{#1}}%
  \ifdim\wd0=0pt
  \else
  _{#1}%
  \fi
}
% \metavar formats a language meta-var.
%
% #1 : a pre-formatted symbol representing the meta-variable
% #2 : a pre-formatted subscript
% #3 : a pre-formatted superscript
% #4 : a pre-formatted prime symbol
% #5 : a natural number, representing the number of primes
%
% Usage:
%   \newcommand{\txmetavar}[3]{
%     \metavar{\tfont{x}}{\tcolor{#1}}{\tcolor{#2}}{\tprime}{#3}
%   }
%   \newcommand{\tx}{\txmetavar{}{}{}}
%   \newcommand{\txone}{\txmetavar{1}{}{}}
%   \newcommand{\txonepr}{\txmetavar{1}{}{1}}
\newcommand{\metavar}[5]{
  #1\@super{#3}{#4}{#5}\@sub{#2}%
}

\makeatother

% \metavarto formats a language meta-var with only a superscript.
%
% #1 : a pre-formatted symbol representing the meta-var
% #2 : a pre-formatted superscript
%
% Usage:
%   \newcommand{\txF}{\metavarto{\tx}{f}}
\newcommand{\metavarto}[2]{\metavar{#1}{}{#2}{}{0}}

% \metavarin formats a language meta-var with only a subscript.
%
% #1 : a pre-formatted symbol representing the meta-var
% #2 : a pre-formatted subscript
%
% Usage:
%   \newcommand{\txone}{\metavarin{\tx}{\tcolor{1}}}
\newcommand{\metavarin}[2]{\metavar{#1}{#2}{}{}{0}}

% \metavarpr formats a language meta-var with only primes, takes 3
% parameters:
%
% #1 : a pre-formatted symbol representing the meta-var
% #2 : a pre-formatted prime symbol
% #3 : a natural number representing the number of primes
%
% Usage:
%   \newcommand{\txpr}{\metavarpr{\tx}{\prime}{1}}
%   \newcommand{\txdubpr}{\metavarpr{\tx}{\prime}{2}}
\newcommand{\metavarpr}[3]{\metavar{#1}{}{}{#2}{#3}}

\makeatletter

% \@globalshadowedcommand generates a new global macro. However, when
% the macro is already defined, it warns the user via a compile time
% message that the macro has been shadowed.
%
% #1 : A default value for the optional argument of the new macro
% #2 : The name of the macro to be defined
% #3 : The number of arguments the macro takes
% #4 : The body of the macro to be defined
%
% Usage:
%  \@globalshadowedcommand{\ae}{0}{
%    \metavar{\tfont{x}}{}{}{}{0}
%  }
\newcommand{\@globalshadowedcommand}[4][]{
  {
    \let\def\gdef
    \ifcsname#2\endcsname
    \message{
      ^^J^^J
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!^^J
      !! mttex Warning: shadowed \@backslashchar#2 when defining metavar macros.^^J
      !! If you need this macro, use \@backslashchar LetLtxMacro to save it.^^J
      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!^^J
      ^^J
    }
    \let\newcommand\renewcommand
    \fi
    \if\relax\detokenize{#1}\relax
    \expandafter\newcommand\csname #2\endcsname[#3]{#4}
    \else
    \expandafter\newcommand\csname #2\endcsname[#3][#1]{#4}
    \fi
  }
}

% \newmetavarStar generates some standard macros for formatting a meta-var,
% and takes 5 paraemters:
%
% #1 : A formatting macro for the meta-var, such a \tfont
% #2 : A formatting macro for the subscripts, superscripts, and primes,
%   such as \tcolor
% #3 : A string prefix for the name of the macro, such as t
% #4 : A string name of the macro, such as ty
% #5 : A string to format and display this meta-variable as, such as
%   \tau
%
% Usage:
%   \newmetavarStar{\tfont}{\tcolor}{t}{ty}{\tau}
%
% This usage generates the following definitions:
%
%  \newcommand{\ttymetavar}[3]{
%    \metavar{\tfont{\tau}}{\tcolor{#1}}{\tcolor{#2}}{\tcolor{\prime}}{#3}
%  }
%
%  \newcommand{\tty}{ \ttymetavar{}{}{} }
%  \newcommand{\ttyin}[1]{ \ttymetavar{#1}{}{0} }
%  \newcommand{\ttyto}[1]{ \ttymetavar{}{#1}{0} }
%  \newcommand{\ttypr}[1][1]{ \ttymetavar{}{}{#1} }
%  \newcommand{\ttyone}{ \ttymetavar{1}{}{} }
%  \newcommand{\ttyonepr}[1][1]{ \ttymetavar{1}{}{#1}}
%  \newcommand{\ttytwo}{ \ttymetavar{2}{}{} }
%  \newcommand{\ttytwopr}{ \ttymetavar{2}{}{1} }
%  \newcommand{\ttytthree}{ \ttymetavar{3}{}{} }
%  \newcommand{\ttytthreepr}{ \ttymetavar{3}{}{1} }
%  \newcommand{\ttyi}{ \ttymetavar{i}{}{} }
%  \newcommand{\ttyipr}[1][1]{ \ttymetavar{i}{}{#1} }
%  \newcommand{\ttyn}{ \ttymetavar{n}{}{} }
%  \newcommand{\ttynpr}[1][1]{ \ttymetavar{n}{}{#1} }
%
%   \ttymetavar takes an unformatted sub-script, super-script, and
%   a natural number n indicating the number of primes. It then formats
%   the sub-script, the super-script, and n primes and attaches them to
%   the formatted meta-variable.
\newcommand{\newmetavarStar}[5]{
  \@globalshadowedcommand{#3#4metavar}{3}{
    \metavar{#1{#5}}{#2{##1}}{#2{##2}}{#2{\prime}}{##3}
  }
  \@globalshadowedcommand{#3#4}{0}{
    \csname #3#4metavar\endcsname{}{}{0}
  }
  \@globalshadowedcommand{#3#4in}{1}{
    \csname #3#4metavar\endcsname{##1}{}{0}
  }
  \@globalshadowedcommand[0]{#3#4to}{2}{
    \csname #3#4metavar\endcsname{}{##2}{##1}
  }
  \@globalshadowedcommand[1]{#3#4pr}{1}{
    \csname #3#4metavar\endcsname{}{}{##1}
  }
  \@globalshadowedcommand{#3#4one}{0}{
    \csname #3#4metavar\endcsname{1}{}{0}
  }
  \@globalshadowedcommand[1]{#3#4onepr}{1}{
    \csname#3#4metavar\endcsname{1}{}{##1}
  }
  \@globalshadowedcommand{#3#4two}{0}{
    \csname #3#4metavar\endcsname{2}{}{0}
  }
  \@globalshadowedcommand[1]{#3#4twopr}{1}{
    \csname #3#4metavar\endcsname{2}{}{##1}
  }
  \@globalshadowedcommand{#3#4three}{0}{
    \csname #3#4metavar\endcsname{3}{}{0}
  }
  \@globalshadowedcommand[1]{#3#4threepr}{1}{
    \csname #3#4metavar\endcsname{3}{}{##1}
  }
  \@globalshadowedcommand{#3#4n}{0}{
    \csname #3#4metavar\endcsname{n}{}{0}
  }
  \@globalshadowedcommand[1]{#3#4npr}{1}{
    \csname #3#4metavar\endcsname{n}{}{##1}
  }
  \@globalshadowedcommand{#3#4i}{0}{
    \csname #3#4metavar\endcsname{i}{}{0}
  }
  \@globalshadowedcommand[1]{#3#4ipr}{1}{
    \csname #3#4metavar\endcsname{i}{}{##1}
  }
}

% \newmetavarNoStar is like \netmetavarStar, but assumes the name of
% the macro is also the display symbol.
% It takes 4 paraemters:
%
% #1 : A formatting macro for the meta-var, such a \tfont
% #2 : A formatting macro for the subscripts, superscripts, and primes,
%   such as \tcolor
% #3 : A string prefix for the name of the macro, such as t
% #4 : A string name of the macro and symbol to format and display, such
%   as x
%
% Usage:
%   \newmetavarNoStar{\tfont}{\tcolor}{t}{x}
%
% This usage is equivalent to
%   \newmetavarStar{\tfont}{\tcolor}{t}{x}{x}
\newcommand{\newmetavarNoStar}[4]{
  \newmetavarStar{#2}{#3}{#4}{#1}{#1}
}

\newcommand{\@newmetavarmaybestar}{
  \@ifstar
  \newmetavarStar
  \newmetavarNoStar
}

% \newmetavar implement the * LaTeX idiom after currying. It expands in
% to either \newmetavarStar or \newmetavarNoStar depending on whether the
% character following its 3rd argument is a * or not.
%
% Usage:
%   \newcommand{\newtmetavar}{\newmetavar{\tfont}{\tcolor}{t}}
%   \newtmetavar{x}
%   \newtmetavar*{ty}{\tau}
\newcommand{\newmetavar}[4]{
  \@newmetavarmaybestar#4{#1}{#2}{#3}
}

% \newmetavarS defines new metavar macros for a list of name/symbol
% pairs. Essentially, it calls \newmetavar* for each name/symbol pair
% in its 4th parameter.
%
% #1 : A formatting macro for the meta-var, such a \tfont
% #2 : A formatting macro for the subscripts, superscripts, and primes,
%   such as \tcolor
% #3 : A string prefix for the name of the macro, such as t
% #4 : A list of name/symbol pairs, separated literally by a /.
%
% Usage:
%   \newmetavarsS{\tfont}{\tcolor}{t}{x/x,e/e,v/v,alpha/\boldsymbol{\alpha}}
%   \newcommand{\newsmetavarsS}{\newmetavarsS{\sfontsym}{\scolor}{s}}
%   \newsmetavarsS{\alpha/\alpha, ty/\sigma}
\newcommand{\newmetavarsS}[4]{
  \foreach \@n/\@d in {#4} {
    \edef \@meow{\noexpand\newmetavarStar{\noexpand#1}{\noexpand#2}{#3}{\@n}{\@d}}
    \@meow
  }
  \def\@meow{\undefined}
  \def\@n{\undefined}
  \def\@d{\undefined}
}

% \newmetavar defines new metavar macros for a list of names, assuming
% each metavar will be displayed via the symbol it is named.
% Essentially, it calls \newmetavar for each name in its 4th parameter.
%
% #1 : A formatting macro for the meta-var, such a \tfont
% #2 : A formatting macro for the subscripts, superscripts, and primes,
%   such as \tcolor
% #3 : A string prefix for the name of the macro, such as t
% #4 : A list of names.
%
% Usage:
%   \newmetavars{\tfont}{\tcolor}{t}{x,e,v}
%   \newcommand{\newsmetavars}{\newmetavars{\sfont}{\scolor}{s}}
%   \newsmetavars{x,e,v}
\newcommand{\newmetavars}[4]{
  \foreach \@n in {#4} {
    \edef \@meow{\noexpand\newmetavarStar{\noexpand#1}{\noexpand#2}{#3}{\@n}{\@n}}
    \@meow
  }
  \def\@meow{\undefined}
  \def\@n{\undefined}
}

% TODO Figure out that currying issue with lists

%%% Spacing commands
%
% See
% http://tex.stackexchange.com/questions/38982/what-is-the-difference-between-mathbin-vs-mathrel
% for a discussion of the default TeX space-affecting character
% classes, namely
%
% \mathord: Ordinary (eg., /)
% \mathop: Large operator (eg., \sum)
% \mathbin: Binary operation (eg., +)
% \mathrel: Relation (eg., =)
% \mathopen: Opening (eg., ()
% \mathclose: Closing (eg., ))
% \mathpunct: Punctuation (eg., ,)

% For language features, we often use "keywords" instead of
% mathematical symbols: if,then,else,let,in,pack,unpack...
%
% It is customary to space these keywords differently, usually with
% more space around them, as for natural language words. The
% definitions below approximate the role of the character classes
% above for keyword symbols.

\newcommand{\kwopen}[1]{#1\,}
\newcommand{\kwclose}[1]{,#1}
\newcommand{\kwbin}[1]{\,#1\,}
\newcommand{\kwrel}[1]{\mathrel{#1}}
\newcommand{\kwinfix}[1]{#1\,}

\newcommand{\maththinbin}[1]{\,#1\,}
\newcommand{\maththickbin}[1]{\:#1\:}
\newcommand{\@thickinfix}[1]{#1\:}

\newcommand{\@quantifier}[4]{\mathopen{#1{#2}} #3 \mathpunct{#1{#4}}}

%%% ----------------- Standard language features ----------------------

%% --------------- Macros for defining new lang exprs ----------------
% NB: State passing is easier and more efficient than closures
% Looks like I don't need to clear up the definitions after use.
% TODO: Make more font parameters, ala issue #40

% \newfeature{suffix}{tag}{args}{def}
\newcommand{\newfeature}[4]{
  \expandafter\newcommand\csname @#2#1\endcsname[#3]{%
    #4%
  }%
  \expandafter\newcommand\csname #2#1\endcsname[2]{%
    \def\langsymfont{##1}%
    \def\langfont{##2}%
    \csname @#2#1\endcsname%
  }%
}

\newcommand{\newtype}{\newfeature{ty}}
\newcommand{\newexpr}{\newfeature{e}}

%% ----------------------- Standard types ----------------------------

% All the following macros itself should only be used through the \newlanguage
% macros.
% All types defined by \newtype{<tag>}{n} generate a macro \<prefix><tag>ty with n
% arguments, where prefixe and formatting is given by the current language.

% type `fun` formats a function type
%
% #1 : The pre-formatted argument to the function
% #2 : The pre-formatted result of the function
\newtype{fun}{2}{#1 \mathbin{\langsymfont{\to}} #2}

% \<prefix>polyfunty formats a polymorphic function type
%
% #1 : The pre-formatted type-variable to bind
% #2 : The pre-formatted argument to the function
% #3 : The pre-formatted result of the function
\newtype{polyfun}{3}{%
  \mathopen{\langsymfont{\forall}}%
  \mathopen{\langsymfont{[}}%
  #1%
  \mathclose{\langsymfont{].}}\mathpunct{}%
  #2%
  \mathbin{\langsymfont{\funarrow}}%
  #3%
}

% type `forall` formats a polymorphic type.
%
% #1 : The pre-formatted type-variable to bind
% #2 : The pre-formatted result in which the type-variable is bound
\newtype{forall}{2}{\@quantifier{\langfontsym}{\forall}{#1}{.} #2}

% type `exist` formats an existential type.
%
% #1 : The pre-formatted type-variable to bind
% #2 : The pre-formatted result in which the type-variable is bound
\newtype{exist}{2}{\@quantifier{\langsymfont}{\exists}{#1}{.} #2}

% type `mu` formats a recursive type.
%
% #1 : The pre-formatted type-variable to bind
% #2 : The pre-formatted result in which the type-variable is bound
\newcommand{\@muty}[3]{\@quantifier{\langsymfont}{\mu}{#1}{.} #2}

% type `pi` formats a dependent function type.
%
% #1 : The pre-formatted variable to bind
% #2 : The pre-formatted argument type
% #3 : The pre-formatted result type
\newtype{pi}{3}{%
  \kwopen{\langsymfont{\Pi}}%
  {#1} \mathbin{:} {#2}%
  \mathclose{.}%
  \mathpunct{}#3%
}

% type `sigma` formats a dependent pair type.
%
% #1 : The pre-formatted variable to bind.
% #2 : The pre-formatted type of the variable.
% #3 : The pre-formatted result type.
\newtype{sigma}{3}{
  \kwopen{\langsymfont{\Sigma}}%
  {#1} \mathbin{:} {#2}%
  \mathclose{.}%
  \mathpunct{}#3%
}

% type `unit` formats a unit type.
\newtype{unit}{0}{\langsymfont{1}}

% type `void` formats a void type.
\newtype{void}{1}{\langsymfont{0}}

% type `bool` formats a bool type.
\newtype{bool}{0}{\langfont{bool}}

% type `type` formats a type of types Type (i.e., a universe).
%
% #1 : A pre-formatted universe level, which defaults to i.
\newtype{type}{1}{\kwopen{\langfont{Type}}_{#1}}

%% TODO: Might need a combinator for defining simple keyword's like Prop and Set?

% type `prop` formats the type Prop, as in CIC's impredicative universe Prop.
\newtype{prop}{0}{\kwopen{\langfont{Prop}}}

% type `set` formats the type Set, as in CIC's predicative universe Set.
\newtype{set}{0}{\kwopen{\langfont{Set}}}

% type `star` formats the type *
\newtype{star}{0}{\langsymfont{\star}}

% type `box` formats the type \square
\newtype{box}{0}{\langsymfont{\square}}

% type `pair` formats a pair type.
%
% #1 : The pre-formatted type for the first component of the pair
% #2 : The pre-formatted type for the second component of the pair
\newtype{pair}{2}{#1 \mathbin{\langsymfont{\times}} #2}

% type `sum` formats a sum type.
%
% #1 : The pre-formatted type for the first component of the sum
% #2 : The pre-formatted type for the second component of the sum
\newtype{sum}{2}{#1 \mathbin{\langsymfont{\plus}} #2}

% type `aexist` formats an existential type, whose type variables require annotations
%
% #1 : The pre-formatted type-variable to bind
% #2 : The pre-formatted type of the type-variable.
% #3 : The pre-formatted result in which the type-variable is bound.
\newtype{aexist}{3}{
  \kwopen{\langsymfont{\exists}}%
  {#1} \mathbin{:} {#2}%
  \mathclose{.}%
  \mathpunct{}#3%
}

% type `nexist` formats an n-ary existential type
%
% #1 : The pre-formatted list of bindings
\newtype{nexist}{1}{
  \kwopen{\langsymfont{\exists}}%
  #1%
}

% type `npi` formats an n-ary dependent function type.
%
% #1 : The pre-formatted variable declarations
% #2 : The pre-formatted result type
\newtype{npi}{2}{
  \kwopen{\langsymfont{\Pi}}%
  #1
  \mathclose{.}%
  \mathpunct{}#2%
}

% type `nsigma` formats an n-ary dependent pair type.
%
% #1 : The pre-formatted list of bindings.
\newtype{nsigma}{1}{
  \kwopen{\langsymfont{\Sigma}}{#1}%
}

%% ----------------------- Standard exprs ----------------------------

% expression `fun` formats a function expression.
%
% #1 : The pre-formatted variable the function binds.
% #2 : The pre-formatted type of the variable.
% #3 : The pre-formatted body of the function.
\newexpr{fun}{3}{%
  \mathopen{\langsymfont{\lambda (}}%
  {#1} \maththinbin{\langsymfont{:}} {#2}% \mathbin{:} spacing would be a bit too large
  \mathclose{\langsymfont{).}}%
  \mathpunct{}#3%
}

% expression `polyfun` formats a polymorphic function expression.
%
% #1 : The pre-formatted type variable the function binds.
% #2 : The pre-formatted variable the function binds.
% #3 : The pre-formatted type of the variable.
% #4 : The pre-formatted body of the function.
\newexpr{polyfun}{4}{
  \mathopen{\langsymfont{\lambda}}%
  \mathopen{\langsymfont{[}}%
  #1%
  \mathclose{\langsymfont{]}}%
  \mathopen{\langsymfont{(}}%
  #2%
  \maththinbin{\langsymfont{:}}%
  #3%
  \mathclose{\langsymfont{).}}\mathpunct{}%
  #4%
}

% expression `abstr` formats an polymorphic abstraction expression.
%
% #1 : The pre-formatted type variable the abstraction binds.
% #2 : The pre-formatted the body of the abstract.
\newexpr{abstr}{2}{\@quantifier{\langsymfont}{\Lambda}{#1}{.} #2}

% expression `inst` formats an instantiation expression.
%
% #1 : The pre-formatted polymorphic abstraction to instantiate.
% #2 : The pre-formatted type with which to instantiate the abstraction.
\newexpr{inst}{2}{\@thickinfix{#1} \mathopen{\langsymfont{[}} #2 \mathclose{\langsymfont{]}}}

% expression `app` formats an application expression.
%
% #1 : The pre-formatted function.
% #2 : The pre-formatted argument.
\newexpr{app}{2}{#1\ #2}

% expression `papp` formats a polymorphic function application expression.
%
% #1 : A pre-formatted polymorphic function expression.
% #2 : A pre-formatted type with which to instantiate.
% #3 : A pre-formatted argument to the function.
\newexpr{papp}{3}{\@thickinfix{\@inste{#1}{#2}} #3}

% expression `if` formats an if expression
%
% #1 : A pre-formatted discriminant expression.
% #2 : A pre-formatted consequent expression.
% #3 : A pre-formatted alternate expression.
\newexpr{if}{3}{\kwopen{\langfont{if}} #1 \kwbin{\langfont{then}} #2 \kwbin{\langfont{else}} #3}

% expression `pack` formats a pack expression
%
% #1 : A pre-formatted type witness.
% #2 : A pre-formatted value witness.
% #3 : A pre-formatted existential type abstracting the witness type.
\newexpr{pack}{3}{%
  \kwopen{\langfont{pack}}%
  \@paire{#1}{#2}%
  \kwbin{\langfont{as}}%
  #3%
}

% expression `unpack` formats an unpack expression
%
% #1 : A pre-formatted type variable.
% #2 : A pre-formatted value variable.
% #3 : A pre-formatted existential witness expression.
% #4 : A pre-formatted expression in which to bind the existential.
\newexpr{unpack}{4}{%
  \kwopen{\langfont{unpack}}%
  \@paire{#1}{#2}%
  \mathbin{=}%
  #3%
  \kwbin{\langfont{in}}%
  #4%
}

% expression `let` formats a let expression
%
% #1 : A pre-formatted expression variable.
% #2 : A pre-formatted expression to bind.
% #3 : A pre-formatted body expression for the let.
\newexpr{let}{3}{%
  \kwopen{\langfont{let}}%
  #1%
  \mathbin{=}%
  #2%
  \kwbin{\langfont{in}}%
  #3}

% expression `alet` formats a let expression with an annotation on the bound expression.
%
% #1 : A pre-formatted expression variable.
% #2 : A pre-formatted expression to bind.
% #3 : A pre-formatted annotation for bound expression.
% #4 : A pre-formatted body expression for the let.
\newexpr{alet}{4}{%
  \kwopen{\langfont{let}}%
  #1%
  \mathbin{=}%
  #2
  \mathbin{:}
  #3%
  \kwbin{\langfont{in}}%
  #4}

% expression `fold` formats a fold expression.
%
% #1 : A pre-formatted mu type.
% #2 : A pre-formatted expression of isorecursive type.
\newexpr{fold}{2}{\kwinfix{\langfont{fold}_{#1}} #2}

% expression `unfold` formats an unfold expression
%
% #1 : A pre-formatted expression of isorecursive type.
\newexpr{unfold}{1}{\kwinfix{\langfont{unfold}} #1}

% expression `unit` formats a unit expression.
\newexpr{unit}{0}{\langsymfont{\langle}\langsymfont{\rangle}}

% expression `fix` formats a recursive function expression.
%
% #1 : The pre-formatted variable the function binds.
% #2 : The pre-formatted type of the variable.
% #3 : The pre-formatted body of the function.
\newexpr{fix}{3}{%
  \kwopen{\langfont{fix}}%
  {#1} \mathbin{:} {#2}% \mathbin{:} spacing would be a bit too large
  \mathclose{.}%
  \mathpunct{}#3}

% expression `true` formats a true expression
\newexpr{true}{0}{\langfont{true}}

% expression `false` formats a false expression
\newexpr{false}{0}{\langfont{false}}

% expression `pair` formats a pair expression.
%
% #1 : A pre-formatted expression for the first component of the pair.
% #2 : A pre-formatted expression for the second component of the pair.
\newexpr{pair}{2}{%
  \mathopen{\langsymfont{\langle}}%
  #1%
  \mathpunct{\langsymfont{,}}%
  #2%
  \mathclose{\langsymfont{\rangle}}%
}

% expression `prj` formats a projection expression.
%
% #1 : An index, such as 1 or 2, indicating which
%   component of the pair to project.
% #2 : A pre-formatted pair expression to project.
\newexpr{prj}{2}{\kwinfix{\langsymfont{\pi}_{#1}} #2}

% expression `sum` formats a sum expression.
%
% #1 : An index, such as 1 or 2, indicating into which
%   side of the sum to inject the expression. 1 indicates left, 2
%   indicates right.
% #2 : A pre-formatted expression to inject into a sum.
\newexpr{sum}{2}{\kwinfix{\langfont{inj}_{#1}} #2}

% expression `case` formats a case expression.
%
% #1 : A pre-formatted discriminant expression.
% #2 : A pre-formatted variable to bind in the left branch.
% #3 : A pre-formatted expression for the left branch.
% #4 : A pre-formatted variable to bind in the right branch.
% #5 : A pre-formatted expression for the right branch.
\newexpr{case}{5}{%
  \kwopen{\langfont{case}}%
  #1%
  \kwbin{\langfont{of}}%
  #2 \mathpunct{.} #3%
  \maththickbin{\langsymfont{|}}%
  #4 \mathpunct{.} #5%
}

% expression `dcase` formats a dependent case analysis expression, like that of CIC's.
%
% #1 : A pre-formatted discriminant expression.
% #2 : A pre-formatted motive.
% #3 : A pre-formatted list of branch expressions.
\newexpr{dcase}{3}{%
  \kwopen{\langfont{case}}%
  #1%
  \mathpunct{,}%
  #2%
  \mathpunct{,}%
  \mathopen{(} #3%
  \mathclose{)}
}

% expression `dpaire` formats a dependent pair expression.
%
% #1 : A pre-formatted expression for the first component of the pair.
% #2 : A pre-formatted expression for the second component of the pair.
% #3 : A pre-formatted expression for the type annotation.
\newexpr{dpair}{3}{%
  \mathopen{\langsymfont{\langle}}%
  #1%
  \mathpunct{,}%
  #2%
  \mathclose{\langsymfont{\rangle}}
  \kwbin{\langfont{as}}%
  #3%
}

% expression `fst` formats a first projection of a pair.
%
% #1 : A pre-formatted expression for the pair to project.
\newexpr{fst}{1}{%
  {\kwopen{\langfont{fst}}#1}%
}

% expression `snd` formats a second projection of a pair.
%
% #1 : A pre-formatted expression for the pair to project.
\newexpr{snd}{1}{%
  {\kwopen{\langfont{snd}}#1}%
}

%% expression `nfun` formats an n-ary function.
%
% #1 : The pre-formatted variable declarations.
% #2 : The pre-formatted body of the function.
\newexpr{nfun}{2}{%
  \kwopen{\langsymfont{\lambda}}%
  #1%
  \mathclose{.}%
  \mathpunct{}#2%
}

% expression `dnpair` formats a dependent n-ary pair expression.
%
% #1 : A pre-formatted list of expressions.
% #2 : A pre-formatted type annotation.
\newexpr{dnpair}{2}{%
  \mathopen{\langsymfont{\langle}}%
  #1%
  \mathclose{{\langsymfont{\rangle}}}%
  \kwbin{\langfont{as}}%
  #2%
}

% expression `packo` is like `pack` but *o*mits the type annotations on the end.
%
% #1 : A pre-formatted type witness.
% #2 : A pre-formatted value witness.
\newexpr{packo}{2}{%
  \kwopen{\langfont{pack}}%
  \@paire{#1}{#2}%
}

% expression `npair` formats an n-ary pair expression, also known as a list.
%
% #1 : A pre-formatted expression for the n elements of the pair
% TODO Would be nice to automagically mathpunct all the commas. should be a simple extension with \foreach parsing
\newexpr{npair}{1}{%
  \mathopen{\langsymfont{\langle}}%
  #1%
  \mathclose{{\langsymfont{\rangle}}}%
}

% expression `npack` formats an n-ary pack expression
%
% #1 : A pre-formatted list of witnesses.
% #2 : A pre-formatted existential type abstracting the witness type.
\newexpr{npack}{2}{%
  \kwopen{\langfont{pack}}%
  \@npaire{#1}%
  \kwbin{\langfont{as}}%
  #2%
}

% expression `npacko` formats an n-ary pack expression, omitting the type annotation.
%
% #1 : A pre-formatted list of witnesses.
\newexpr{npacko}{1}{%
  \kwopen{\langfont{pack}}%
  \@npaire{#1}%
}

% expression `nunpack` formats an n-ary unpack expression
%
% #1 : A pre-formatted list of variables.
% #2 : A pre-formatted existential witness expression.
% #3 : A pre-formatted expression in which to bind the existential.
\newexpr{nunpack}{3}{%
  \kwopen{\langfont{unpack}}%
  \@npaire{#1}%
  \mathbin{=}%
  #2%
  \kwbin{\langfont{in}}%
  #3%
}

% expression `nfix` formats an n-ary recursive function expression.
%
% #1 : The per-formatted name of the recursive function.
% #2 : The pre-formatted list of variables the function binds.
% #3 : The pre-formatted type of the recursive function.
% #4 : The pre-formatted body of the function.
\newexpr{nfix}{4}{%
  \kwopen{\langfont{fix}}%
  {#1} (#2) \mathbin{:} {#3}
  \mathclose{.}%
  \mathpunct{}#4%
}

% TODO: Need some error handling. If a macro given to newlanguage and passed here is undefined, you get an error like
% "argument of \sfontsym has an extra }", which makes no sense.

% \newconstr generates a macro for formatting a language construct.
%
% #1 : A formatting macro for symbols, such as \tfontsym
% #2 : A formatting macro for text, such as \tfont
% #3 : A construct tag, such as fun
% #4 : A construct type, either ty or e
% #5 : The name of the macro to generate
\newcommand{\newconstr}[5]{
  \@globalshadowedcommand{#5}{0}{
    \csname#3#4\endcsname{#1}{#2}
  }
}

% \@newconstrs generates formatting macros for a list of language
% constructs
%
% #1 : A formatting macro for symbols, such as \tfontsym
% #2 : A formatting macro for text, such as \tfont
% #3 : A construct kind, either ty or e
% #4 : A prefix to use when generating the macro names
% #5 : A suffix to use when generating the macro names
% #6 : A list of construct tags, such as {fun,bool,unit,void}
\newcommand{\@newconstrs}[6]{
  {
    \foreach \@n in {#6}{
      \edef\@meow{\noexpand\newconstr{\noexpand#1}{\noexpand#2}{\@n}{#3}{#4\@n#5}}
      \@meow
    }
    \def\@meow{\undefined}
    \def\@n{\undefined}
  }
}

% \newtypes generates type formatting macros given a list of tags.
%
% #1 : A formatting macro for symbols, such as \tfontsym
% #2 : A formatting macro for text, such as \tfont
% #3 : A prefix for the name of each macro, such as t
% #4 : A suffix for the name of each macro, such as ty
% #5 : A list of type tags, such as {fun,bool,void,unit}
\newcommand{\newtypes}[2]{\@newconstrs{#1}{#2}{ty}}

% \newexprs generates type formatting macros given a list of tags.
%
% #1 : A formatting macro for symbols, such as \sfontsym
% #2 : A formatting macro for text, such as \sfont
% #3 : A prefix for the name of each macro, such as s
% #4 : A suffix for the name of each macro, such as e
% #5 : A list of type tags, such as {fun,bool,void,unit}
\newcommand{\newexprs}[2]{\@newconstrs{#1}{#2}{e}}
\makeatother

% \newlanguage generates macros for formatting meta-variables, types,
% and expressions of a language.
%
% #1 : A formatting macro for super-scripts, sub-scripts, and primes in
%   this language, such as \tcolor
% #2 : A formatting macro for math text in this language, such as \tfont
% #3 : A formatting macro for symbols in this language, such as
%   \tfontsym
% #4 : A language prefix for the macros, such as t
% #5 : A list of meta-variables for which to generate macros via
%   \newmetavars, such as {x, e, v}
% #6 : A list of meta-variables for which to generate macros via
%   \newmetavarsS, such as {ty/\tau,alpha\alpha}
% #7 : A list of types for which to generate macros via \newtypes, such
%   as {fun, forall, exist, pair, bool, unit}. The macros are generated
%   with the language prefix and the suffix ty.
% #8 : A list of expressions for which to generate macros via
%   \newexprs, such as {fun, app, if, true, false, unit}. The macros
%   are generated with the language prefix and the suffix e.
\renewcommand{\newlanguage}[8]{
  \newmetavars{#2}{#1}{#4}{#5}
  \newmetavarsS{#3}{#1}{#4}{#6}
  \newtypes{#3}{#2}{#4}{ty}{#7}
  \newexprs{#3}{#2}{#4}{e}{#8}
}

%%% Standard meta-theory

% \wf formats a well-formedness judgment.
%
% #1 : Pre-formatted assumptions, such as \tfont{\Delta}
% #2 : The pre-formatted proposition, such as \tfont{\alpha}
\newcommand{\wf}[2]{#1 \mathrel{\vdash} #2}

% \judg formats a well-typedness judgment.
% It takes 3 parameters.
%
% #1 : The assumptions, such as \tfont{\Delta};\tfont{\Gamma}
% #2 : The term, such as \tfont{e}
% #3 : The type, such as \tfont{\tau}
\newcommand{\judg}[3]{\wf{#1}{#2 \mathrel{:} #3}}

%% Context typing

% \ctxarrowty formats a context typing arrow
%
% #1 : A formatting macro for symbols, such as \stfontsym
% #2 : The type of the hole
% #3 : The type of the result
\newcommand{\ctxarrowty}[3]{#2 \mathrel{#1{\ctxarrow}} #3}

% \ctxty formats a context type, with different typing contexts for the
% hole and result
%
% #1 : A formatting macro for symbols, such as \stfontsym
% #2 : The typing contexts for the hole
% #3 : The type of the hole
% #4 : The typing contexts for the result
% #5 : The type of the result
\newcommand{\ctxty}[5]{\ctxarrowty{#1}{(\wf{#2}{#3})}{(\wf{#4}{#5})}}

% \ctxtyjudg formats a context typing judgment.
%
% #1 : A formatting macro for symbols, such as \stfontsym
% #2 : A pre-formatted context
% #3 : The typing contexts for the hole
% #4 : The type of the hole
% #5 : The typing contexts for the result
% #6 : The type of the result
\newcommand{\ctxtyjudg}[2]{\judg{}{#2}{\ctxty{#1}}}


%% Contextual equivalence
\newcommand{\ctxeqvsym}{\approx^{\mathit{ctx}}}
\newcommand{\ciueqvsym}{\approx^{\mathit{ciu}}}

% \ciueqvjudg formats a c.i.u. equivalence judgment.
%
% #1 : Pre-formatted typing contexts, such as
%   \tfont{\Delta};\tfont{\Gamma}
% #2 : A pre-formatted expression
% #3 : A pre-formatted c.i.u. equivalent expression
% #4 : A pre-formatted type for the expressions
\newcommand{\ciueqvjudg}[4]{\judg{#1}{#2 \mathrel{\ciueqvsym} #3}{#4}}

% \ctxeqvjudg formats a contextual equivalence judgment.
%
% #1 : Pre-formatted typing contexts, such as
%   \tfont{\Delta};\tfont{\Gamma}
% #2 : A pre-formatted expression
% #3 : A pre-formatted contextually equivalent expression
% #4 : A pre-formatted type for the expressions
\newcommand{\ctxeqvjudg}[4]{\judg{#1}{#2 \mathrel{\ctxeqvsym} #3}{#4}}

%% Logical Relations
\newcommand{\lratomsym}{\mathrm{Atom}}
\newcommand{\lratomvalsym}{\mathrm{Atom}^{\mathrm{val}}}
\newcommand{\lrrelsym}{\mathrm{Rel}}

% \lr formats a logical relation set.
%
% #1 : A formatting macro, such as \tfont
% #2 : A letter for the relation, such a V or E
% #3 : A pre-formatted index for the relation
%
% Usage:
%  \newcommand{\srelV}{\lr{\sfont}{V}}
%  \newcommand{\trelV}{\lr{\tfont}{V}}
\newcommand{\lr}[3]{#1{\mathcal{#2}}\sembrace{#3}}

% \lrV,\lrE,\lrG,\lrD,\lrK,\lrO format logical relation sets.
%
% #1 : A formatting macro, such as \tfont
% #2 : A pre-formatted index for relation
%
% Usage:
%  \newcommand{\srelV}{\lrV{\sfont}}
%  \newcommand{\trelV}{\lrV{\tfont}}
\newcommand{\lrV}[2]{\lr{#1}{V}{#2}}
\newcommand{\lrE}[2]{\lr{#1}{E}{#2}}
\newcommand{\lrG}[2]{\lr{#1}{G}{#2}}
\newcommand{\lrD}[2]{\lr{#1}{D}{#2}}
\newcommand{\lrK}[2]{\lr{#1}{K}{#2}}
\newcommand{\lrO}[2]{\lr{#1}{O}{#2}}

%% The following help define formatting macros relational
%% interpretations and substitution, normally written as \rho, \delta,
%% and \gamma

%% TODO Maybe these should use \pair and \triple
% \mapext extends a key/value map
%
% #1 : A pre-formatted symbol for the map, such as \tfont{\gamma}
% #2 : A pre-formatted key for the new mapping, such as \tfont{\tx}
% #3 : A pre-formatted symbol for the value of the new mapping such as
%   \tfont{\tau}
%
% Usage:
%  \newcommand{\btrlrgamma}{\btrfont{\gamma}}
%  \newcommand{\btrlrgammaext}{\mapext{\btrlrgamma}}
\newcommand{\mapext}[3]{#1[#2 \mapsto #3 ]}

% \binmapext extends a map whose value is a pair.
%
% #1 : A pre-formatted symbol for the map, such as \tfont{\rho}
% #2 : A pre-formatted key for the new mapping, such as \tfont{\alpha}
% #3 : A pre-formatted symbol for the first element of the value such as
%   \tfont{\tau}
% #4 : A pre-formatted symbol for the second element of the value
%
% Usage:
%  \newcommand{\slrgamma}{\sfont{\gamma}}
%  \newcommand{\slrgammaext}{\binmapext{\slrgamma}}
\newcommand{\binmapext}[4]{\mapext{#1}{#2}{(#3,#4)}}

% \trimapext is like \binmapext, but extends a map whose value is a triple.
%
% #1 : A pre-formatted symbol for the map, such as \tfont{\rho}
% #2 : A pre-formatted key for the new mapping, such as \tfont{\alpha}
% #3 : A pre-formatted symbol for the first element of the value such as
%   \tfont{\tau}
% #4 : A pre-formatted symbol for the second element of the value
% #5 : A pre-formatted symbol for the third element of the value
%
% Usage:
%  \newcommand{\tlrrho}{\tfont{\rho}}
%  \newcommand{\tlrrhoext}{\trimapext{\tlrrho}}
\newcommand{\trimapext}[5]{\mapext{#1}{#2}{(#3,#4,#5)}}

%% TODO These should probably accept formatting macros for the
%% subscript.

% \mapat applies a map to a key key.
%
% #1 : A pre-formatted symbol for the map, as as \tfont{\rho}
% #2 : A pre-formatted symbol for the key
\newcommand{\mapat}[2]{{#1}({#2})}

% \maponeat projects the first element of the value of a map at some
% key.
%
% #1 : A pre-formatted symbol for the map, as as \tfont{\rho}
% #2 : A pre-formatted symbol for the key
\newcommand{\maponeat}[1]{\mapat{{#1}_1}}

% \maptwoat is like \maponeat but projects the second element.
% The interface is the same
\newcommand{\maptwoat}[1]{\mapat{{#1}_2}}

% \maprelat is like \maponeat but projects the third element, which is
% assumed to be a relation.
\newcommand{\maprelat}[1]{\mapat{{#1}_R}}

%% Standard Source/Target formatting
\makeatletter
\newcommand*{\slang}{\@source-language-undefined}
\newcommand*{\tlang}{\@target-language-undefined}
\makeatother

\makeatletter
\newcommand{\mathcolor}[2]{%
  \begingroup
  \colorlet{out}{.}\color{#1}#2\@ifnextchar_{\do@mathcolorsub}{\endgroup}%
}
\newcommand{\do@mathcolorsub}[2]{%
  _{{\color{out}#2}}\@ifnextchar^{\do@mathcolorsup}{\endgroup}%
}
\newcommand{\do@mathcolorsup}[2]{%
  ^{\color{out}#2}\endgroup
}
\makeatother

% -------------
% CIC Stuff

% \ind formats an inductive declarations
% #1 : A pre-formatted name for the inductive.
% #2 : A pre-formatted meta-expression representing the number of parameters.
% #3 : A pre-formatted expression for the type of the inductive type.
% #4 : A pre-formatted local environment expression representing the constructor declarations.
\newcommand{\ind}[4]{#1\mathbin{:}\mathopen{[}#2\mathclose{]}#3\mathbin{:=}#4}

% branch type computation
\newcommand{\brty}[2]{\{#1\}^{#2}}

% annotated branch type
\newcommand{\abrty}[3]{\{#1\mathbin{:}#2\}^{#3}}

% allowable elimination sorts judgment.
\newcommand{\aesjudg}[2]{[#1\mathpunct{\mid}#2]}

% allowable elimination sorts, annotated, judgment.
\newcommand{\aesajudg}[3]{[#1\mathbin{:}#2\mathpunct{\mid}#3]}

% recursive position
\newcommand{\recpos}[2]{RP (#1,#2)}

% terminates judgment
\newcommand{\terminates}[2]{\wf{#1}{#2\text{ terminates}}}

% guard condition
% based on Gim{\'{e}}nez
\newcommand{\guardjudg}[5]{\mathcal{D}_{#4} (#1,#2,#3,#5)}

% ----------

\newcommand{\scolor}[1]{\mathcolor{blue}{#1}}
\newcommand{\tcolor}[1]{\mathcolor{red}{#1}}

\newcommand{\sfonttext}[1]{\textsf{\scolor{#1}}}
\newcommand{\tfonttext}[1]{\textbf{\tcolor{#1}}}

\newcommand{\sfont}[1]{\scolor{\mathsf{#1}}}
\newcommand{\tfont}[1]{\tcolor{\mathbf{#1}}}

\newcommand{\sfontsym}[1]{\sfont{#1}}
\newcommand{\tfontsym}[1]{\tfont{\boldsymbol{#1}}}

\newcommand{\scal}[1]{\sfontsym{\mathcal{#1}}}
\newcommand{\tcal}[1]{\tfontsym{\mathcal{#1}}}

\newcommand{\sprime}{\scolor{\prime}}
\newcommand{\tprime}{\tcolor{\prime}}

\endinput
